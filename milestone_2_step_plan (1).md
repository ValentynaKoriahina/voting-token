# Milestone 2 — Простой смарт-контракт (Полный перевод задания)

## **V2.1 Область работы**
Реализовать интерфейс **ERC-20** с нуля (взять за основу `IERC20` интерфейс).  
⚠️ **Не использовать** готовую реализацию `ERC20` из OpenZeppelin.  
Реализовать самостоятельно функции `transfer`, `balanceOf` и другие из `IERC20`.  
Документация: [OpenZeppelin — Extending Contracts](https://docs.openzeppelin.com/contracts/5.x/extending-contracts)

---

## **V2.2 Расширенная область**
Помимо обычных функций `IERC20`, добавить следующие **дополнительные нефункциональные возможности**:

1. Владельцы токенов, у которых **более 0.1 % от общего объёма**, могут **начинать голосование** за изменение цены токена.  
2. Владельцы токенов, у которых **более 0.05 %** (минимум `minTokenAmount`) от общего объёма, могут **голосовать** за определённую цену через функцию:
   ```solidity
   function vote(uint256 price)
   ```
3. Время голосования определяется константой `timeToVote` в контракте или передаётся в **конструкторе**.  
4. **Сила голоса** равна количеству токенов у владельца.  
   Например, если пользователи A и B владеют по 100 токенов, а C — 250, то даже если A и B проголосуют одинаково, **побеждает цена, за которую проголосовал C**.  
5. Должна быть возможность **покупать и продавать токены за эфир**, исходя из текущей цены:
   - `buy`: минтит новые токены за эфир;
   - `sell`: сжигает токены и возвращает эфир из баланса контракта.  
6. Администратор может настраивать **процент комиссии** для функций `buy` и `sell`.  
   Комиссия **накапливается и сжигается еженедельно**.  
7. На период активного голосования **запрещается** выполнять `transfer`, `buy` и `sell` для пользователей, которые уже проголосовали.


---

## **Функциональные требования**
- Использовать **TypeChain** для генерации типов контрактов в тестах.  
- Контракт должен быть **обновляемым (upgradeable)**.  
- Функцию `endVoting` может вызвать **любой пользователь**, но правила должны проверять, что она вызывается **только после истечения времени `timeToVote`**.  
- Контракты должны быть **задеплоены в тестовую сеть Sepolia** и **проверены на Etherscan (sepolia.etherscan.io)**.

---

## **Тестирование**
Реализовать следующие тесты:

- `startVoting` изменяет значения `votingStartedTime`, `votingNumber` и **эмитит событие `VotingStarted`**.  
- Транзакции `vote` проходят или отклоняются в зависимости от того, есть ли у пользователя как минимум **0.05 % токенов** от общего объёма.  
- Проверить, что **передача токенов** не позволяет пользователям **дважды участвовать в голосовании**.  
Защитить контракт от сценария:
  ```
  Пользователь A голосует с X токенами
  Пользователь B ещё не голосует, у него Y токенов
  A переводит X токенов B → у B теперь X+Y
  B голосует с X+Y токенами ❌ (нельзя)
  ```
- Использовать **путешествия во времени (time travel)** в тестах через Hardhat.  
- Каждый тест должен проверять, что **соответствующее событие было сгенерировано**.  
- Отображать значения в формате **eth**, **gwei** или **wei** (для эфира и токенов).

---

## **Технологический стек**
- **Solidity** — для смарт-контрактов  
- **Ethers.js** (на TypeScript) или **Nethereum** (на F#) — для тестов  
- **Hardhat** — для локальной сети и тестирования  
- **RedDuck Type Provider** — для F# (если используется .NET)  

Руководство: *Build and Deploy Smart Contracts using Hardhat*

---

## **FAQ**
**Вопрос:** Как сделать, чтобы контракт автоматически выполнял действие X в определённое время?  
**Ответ:** Никак. Контракты не могут работать автоматически.  
Все функции выполняются только при вызове транзакции, а любая транзакция имеет ограничение по времени и сложности (`gas limit`).  
Цикл, который сам что-то вызывает каждые N минут, **невозможен** в Solidity. Это можно реализовать только **в оффчейн-скриптах** (например, через `ethers.js`).  
Альтернативы: **Chainlink Keepers** или **Gelato AutoTask**, но за их услуги нужно платить.

---

## **Изученные темы**
- Форматирование значений (**wei**, **gwei**, **eth**)  
- **IERC20**, **ERC20**  
- **Solidity**  
- **Ethers.js + Hardhat**  
- **Gas**  
- **Memoization pattern**

---

## **Решённая проблема**
- Проблема циклов и функций `O(N)`, зависящих от действий пользователей.

